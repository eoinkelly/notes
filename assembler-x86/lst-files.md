# List files

From yasm manual

> List files typically intermix the original source with the machine
> code generated by the assembler. The default list format is “nasm”,
> which mimics the NASM list file format.

From `nasm` manual

> Causes an assembly listing to be directed to the given file, in
> which the original source is displayed on the right hand side (plus
> the source for included files and the expansions of multi-line
> macros) and the generated code is shown in hex on the left.

* shows assembly source on right beside the generated code on the left
* listing files are generated by the assembler
* seem to be designed for human consumption for debugging
* multiple formats are available but yasm only supports _nasm style_ format by default.

# nasm list file format

* first line is odd
    ```
        1                                 %line 1+1 first.s
    ```
* a .lst file will contain the instructions from many files - I presume the first line is some sort of header identifying which file the following instructions come from
* it reads like the original .s file with comments removed except all lines are moved down by one
* assembler directives are wrapped in []

Instruction Line format:

```
{line number} {instruction offset} {instruction op code} {symbolic instruction as per assembly source}
```

* instruction offset
    * 6 hex digits
    * offset of the instruction in the instruction stream
    * this is my guess from inspection, have not confirmed anywhere
*  instruction op code
    * 0-14 hex digits or `<gap>`
    * hex representing the actual instruction in the stream
    * this is my guess from inspection, have not confirmed anywhere

## Aside: endianness

* refers to *byte* order not *bit* order
* is lifted from Gullivers travels
* big endian: most significant byte stored first
    * network protocols generally transmit bytes big endian
    * also called "network byte order"
    * the way we write down decimal numbers is big endian (we write most significant digit first)
* little endian: least significant byte stored first
    * x86 processors (chosen in '60's, no particularly good reasons for it)
* some ARM processors can switch endianness for different instructions:w

# CPU stores number least significant byte first

* WARNING: in .lst files you will see hex representations of numbers defined in
  your assembly but the *byte* (not bit) order is reversed
    * The CPU stores the least significant byte first

```
; example .lst file snippet
; notice that the bytes are flipped from how we would expect

     5 00000000 00000000               zero dd 0
     6 00000004 01000000               one dd 1
```

