# Mutlifactor auth

> there has to be some form of synchronization that allows both you and the
> computer system to use the same, ever-changing password, without the computer
> having to transmit it to you each time by some insecure method such as email.

> the computer system would generate the one-time password, send it to you in an
> SMS text message, and then allow you a certain time period to type it in
> before the password expired. A mail-based system works in essentially the same
> way, but the password would have to be valid for longer to allow for delays in
> transit (some banks will mail you a whole printed list of one-time passwords,
> called transaction authentication numbers or TANs, that you use and then
> strike out in sequence, matching a list of passwords stored on the computer
> system).

> Time synchronization, involves the token and the computer system both
> generating new one-time passwords based on a numeric version of the current
> time. They might take the time, say 5:08PM, turn it into a numerical code,
> 1708, then run it through a code generator and an algorithm (a mathematical
> process) called a hash function (or hash code) to generate a unique 10-digit
> code, which becomes your one-time password. As long as the token and the
> computer system have their clocks synchronized, the token will always generate
> a one-time password that matches the one the computer is looking for. But if
> the clocks get out of step, the token won't generate correct passwords anymore
> and will need to be reset.

> A different method involves the computer system and the token starting with a
> shared number called a seed and generating a new one-time password using a
> constantly advancing counter. The first time a password is needed, the
> computer and the token use the counter number 0001 with the seed number to
> generate the password; some time in the future after lots of passwords have
> been generated, the counter might stand at 0299 inside both the computer and
> the token, so that number would be used with the seed to generate the password
> for the next time. This technique is called counter synchronization and
> doesn't suffer from the disadvantage of keeping clocks in step

Methods of generating one time passwords:

1. Time synchronization
1. Counter synchronization

Google authenticator

Supports

- Time-based One-time password algorithm
- HMAC-based One-time password algorithm

https://tools.ietf.org/html/rfc6238 https://tools.ietf.org/html/rfc4226

HMAC = Hash-based message authentication code
https://en.wikipedia.org/wiki/Hash-based_message_authentication_code

> To log into a site or service that uses two-factor authentication, the user
> provides user name and password to the site and runs the Authenticator app.
> The app displays an additional six-digit one-time password. The same password
> is independently generated by the site, which asks the user for it. The user
> enters it, thus authenticating the user's identity.

> the site provides a shared secret key to the user over a secure channel, to be
> stored in the Authenticator app. This secret key will be used for all future
> logins to the site

> The service provider generates an 80-bit secret key for each user (whereas RFC
> 4226 ยง4 requires 128 bits and recommends 160 bits).[37] This is provided as a
> 16, 26 or 32 character base32 string or as a QR code. The client creates an
> HMAC-SHA1 using this secret key. The message that is HMAC-ed can be:
>
> 1. the number of 30-second periods having elapsed since the Unix epoch (TOTP);
>    or
> 2. the counter that is incremented with each new code (HOTP).

A portion of the HMAC is extracted and converted to a six-digit code.
