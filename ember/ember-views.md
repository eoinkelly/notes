# Ember.View

## Questions

- can i override autogenerated views that go with a template like i can with
  routes/controllers etc.?

## General

- Views are arranged in a heirarchy
- "View heirarchies are usually created by evaluating a handlebars template"
    - => a single template can create multiple views
    - views are automagically created to be the logic that backs a template
    - a template is like a blueprint for creating views
    - the template will automatically create views for you
    - templates are kind of a declarative way to create views
- Every handlebars expression e.g. `{{foo}}` creates a view object to manage
  it's binding
- You can change the view heirarchy at run-time using `Ember.ContainerView`
- views contain child views in the same way that DOM nodes contain their
  children

- There doesn't seem to be a naming convention for views ???

- The naming convention isn't :w

How are views and templates related?

- Many views can use the same template
- A template can cause many views to be instantiated

## How does ember handle DOM events?

1. It delegates everything to the top level ember app element (usually `<body>`)
    - ember registers **one** event handler for each type of event so you never
      need to change them over the lifetime of your app
    - so you don't have to delegate/undelegate events when you add/remove child
      view
2. it finds the view nearest to the event origin that has a handler for the
   event and gives the event to it.

## Ember view rendering timeline

- application calls `append` or `appendTo` on the view
    - this causes the view to be scheduled to be rendered (allowing binding sync
      to happen first)
- Ember creates a RenderBuffer and gives it to the view and tells it to append
  it's content to it
    - If the view needs to create child views, it will create RenderBuffers for
      them \* child RenderBuffers have a link back to the parent RenderBuffer

By the time that the top levewl view has finished rendering, Ember has two trees
in memory

1. a tree of View objects
2. a tree of RenderBuffer objects

Now Ember walks down the tree of RenderBuffers, converting them to strings

A RenderBuffer also encapsulates an element's tag name and attributes which
makes it possible for the render process to modify them even **after** it's
children have been rendered. This is important because bindings in the children
could affect them

Ember then uses jQuery to convert the string into an element

## Virtual views

- `{{if}}` and `{{with}}` create virtual views
- they are for Ember's internal bookeeping only
- they are "virtual" because they don't appear in the `parentView` or
  `childView` properties
- you can get at them using `this.get('_parentView')` or
  `this.get('_childViews')` but doing so is bad form

## Ember.ContainerView

- Used when you have an area of your page that you want total view control over
  and that area is more complex than can be represented by a single view
- You can build up an arbitrarily complex tree of views since child views can
  themselves be instances of `Ember.ContainerView`
- exposes an array of child view instances
- contains no text - is made up entirely of child views
- is a way to programmatically build up a view heirarchy (nested arrays of
  views)
- has the properties
    - a writable `childViews` array
    - a `currentView` - when set it adds the view to the `childViews` array and
      removes the old value of `currentView` from the `childViews` array - this
      eems odd???

A ContainerView is an Ember.View subclass that implements Ember.MutableArray
allowing programmatic management of its child views.

- `Ember.ContainerView` is a subclass of `Ember.View` (just like
  `Ember.Component` is)
- It implementes `Ember.MutableArray` ???
    - `pushObject()`
    - `removeObject()`
    - `toArray()`
- It allows you to manage child views in JS rather than implicitly in the
  templates

The following properties exist in `Ember.View` but do not make sense in an
`Ember.ContainerView`:

- template
- templateName,
- defaultTemplate,
- layout,
- layoutName
- defaultLayout

These will not result in the template or layout being rendered. The HTML
contents of a `Ember.ContainerView` DOM representation will **only be the
rendered HTML of its child views**.

### Example code for `Ember.ContainerView`

```
// MyApp namespace
window.MyApp = Ember.Application.create();

// Create the container
MyApp.container = Ember.ContainerView.create();

// Append the container to the document body
MyApp.container.append();
MyApp.container.appendTo('#foo'); // where '#foo' is a string|DOM element|jQuery selector
// You can also plug a ContainerView into your app using the {{view}} handlebars
// helper in a template:
//      {{view App.container}}

// Grab child views array
var childViews = MyApp.container.get('childViews');

// Add text field
childViews.pushObject(Ember.TextField.create({
      value: 'Test'
}));

// Add checkbox
childViews.pushObject(Ember.Checkbox.create({
      value: true
}));

// Add custom view
childViews.pushObject(Ember.View.create({
      template: Handlebars.compile('<label>Awesome-O</label>')
}));
```

## View properties

```
attributeBindings: [] // a list of view properties to apply as attributes of the containing element
element: // returns the current DOM element for the view
isVisible: // is this view currently visible in the DOM
nearestOfType: // return the view object that is an instance of the provided class/mixin
                // this.nearestOfType(App.SomeKindOfView)

views: // a reference to the global views hash ???
classNames: []
classNameBindings: [] // a list of view properties to apply as class names to the containing element
tagName: 'div' // a string representing the HTML tag that will enclose the view
template: // function that gets a context and returns a HTML string
templateName: // the name of a template in Ember[TEMPLATES]
defaultTemplate: // function takes a context and returns HTML string,
templateVariables:  // an object containing the variables that were in scope when
                    // the view was rendered

controller: // reference to an object that will be used as a context
            // if a view does not have an explicity controller property it will inherit the propertiy from it's parent
context: // reference to an object from which the template should access properties
parentView: a reference to the "parent" view //if neither controller nor context are set, then the parentView's context will be used

layout: // a function that takes a context and returns HTML string.
// the template you use for layout must have exactly one {{yield}} in it
        // it will wrap the output of 'template' (or 'templateName')
layoutName: // string representing the name of a layout template

// * NB events in eventManager take precedence over events in child views that
//   are defined directly in that view
eventManager {
    // event handlers
    // * handlers in here swallow events so that child views will not see them.
    //   How does this work?
    click: function(jQueryEvent, view) {
        // stop propagation with
        jQueryEvent.stopPropagation()
        // or
        return false; // same as jquery
    }
    mouseEnter: function(jQueryEvent, view) { }
}

// event handlers
// **************

// * any handlers defined in eventManager will override these
// * these handlers get different params than the handlers in eventManager

click: function(jQueryEvent) { }
mouseEnter: function(jQueryEvent) { }
// ...

```

If your template contains `{{view App.SomeView}}` then that view will be
rendered as a child view into the place where it appears in the template

### Disadvantages of using `eventManager`

- you cannot call the handler methods from other parts of your view as easily -
  really???
- You can inherit event handlers individually (which you can't do if they are
  all in one object (`eventManager`)

## View Methods

render() createElement() // called recursively by render() // lifecycle hooks
didInsertElement() willClearRender()

rerender() // redo the rendering process

$ // jquery object for this view's element e.g. myView.$('li') // find all <li>
tags in current view

Ember.CollectionView.extend() // ???

Within a view `this.get('content')` will get you the context object (the object
that has properties you need)

Make a view by

```
Ember.View.extend({});
```

```
// A pattern for running code after your view has been rendered
// * Just before the view is about to be rendered, you add some code ot the 'afterRender' queue which will be run once just afterwards
App.SomeView = Em.View.extend({
  template: '{{template "lots_of_images"}}',
  didInsertElement: function(){
    // This callback runs before lots_of_images has rendered.
    this.scheduleMasonry();
  },
  scheduleMasonry: (function(){
    // scheduleOnce debounces applyMasonry to only run once per
    // runloop. scheduleMasonry is called on didInsertElement, and
    // whenever controller.images changes.
    Ember.run.scheduleOnce('afterRender', this, this.applyMasonry);
  }).observes('controller.images.@each'),
  applyMasonry: function(){
    // http://masonry.desandro.com/index.html
    this.$('.container').masonry({
      itemSelector: '.item',
      columnWidth: 150
    });
  }
});

## Getting access to parents and children

Within a view
```

this.get('parentView'); // our parent this.get('childViews'); // array of child
view objects

```

Views have lifecycle hooks that you can attach handlers to

* willInsertElement
* didInsertElement
* willDestroyElement
* willClearRender
* becomeVisible
* becameHidden

You can register listeners to these events from outside the view (if you have a
reference to it)
```

view.on('willClearRender', function () { });

```
This works because views use Ember's evented stuff

Ember comes wiht a bunch of events already defined incl. the drag & drop ones


The only way to craete a view hierarchy using templates is with the {{view}} helper

* Handlebars templates have a notion of the 'current view' (the view that is
closest)
* it is accessible through the `{{view}}` helper e.g.
    {{view.someProp}}
* even though the handlebars context is the controller, {{view}} still points at
  the view

* Handlebars contexts can inherit properties from their parent contexts !!!
* Helpers can also create variables e.g. `{{#each users as user` creates `user` in the enclosed context
```
