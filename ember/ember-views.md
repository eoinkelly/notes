# Ember.View

## Questions

* can i override autogenerated views that go with a template like i can with routes/controllers etc.?

## General

* Views are arranged in a heirarchy
* "View heirarchies are usually created by evaluating a handlebars template"
    * => a single template can create multiple views
    * views are automagically created to be the logic that backs a template
    * a template is like a blueprint for creating views
    * the template will automatically create views for you
    * templates are kind of a declarative way to create views
* Every handlebars expression e.g. `{{foo}}` creates a view object to manage it's binding
* You can change the view heirarchy at run-time using `Ember.ContainerView`
* views contain child views in the same way that DOM nodes contain their children

* There doesn't seem to be a naming convention for views ???

* The naming convention isn't :w


How are views and templates related?

* Many views can use the same template
* A template can cause many views to be instantiated

## How does ember handle DOM events?

1. It delegates everything to the top level ember app element (usually `<body>`)
    * ember registers **one** event handler for each type of event so you never
      need to change them over the lifetime of your app
    * so you don't have to delegate/undelegate events when you add/remove child view 
2. it finds the view nearest to the event origin that has a handler for the
   event and gives the event to it.

## Ember view rendering timeline

* application calls `append` or `appendTo` on the view
    * this causes the view to be scheduled to be rendered (allowing binding sync to happen first)
* Ember creates a RenderBuffer and gives it to the view and tells it to append it's content to it
    * If the view needs to create child views, it will create RenderBuffers for them * child RenderBuffers have a link back to the parent RenderBuffer

By the time that the top levewl view has finished rendering, Ember has two trees in memory

1. a tree of View objects
2. a tree of RenderBuffer objects

Now Ember walks down the tree of RenderBuffers, converting them to strings

A RenderBuffer also encapsulates an element's tag name and attributes which
makes it possible for the render process to modify them even **after** it's
children have been rendered. This is important because bindings in the children
could affect them

Ember then uses jQuery to convert the string into an element

## Virtual views

* `{{if}}` and `{{with}}` create virtual views 
* they are for Ember's internal bookeeping only
* they are "virtual" because they don't appear in the `parentView` or `childView` properties
* you can get at them using `this.get('_parentView')` or `this.get('_childViews')` but doing so is bad form

## Ember.ContainerView

* Used when you have an area of your page that you want total view control over
  and that area is more complex than can be represented by a single view
* You can build up an arbitrarily complex tree of views since child views can
  themselves be instances of `Ember.ContainerView`
* exposes an array of child view instances
* contains no text - is made up entirely of child views
* is a way to programmatically build up a view heirarchy (nested arrays of views)
* has the properties
    * a writable `childViews` array
    * a `currentView` - when set it adds the view to the `childViews` array and
      removes the old value of `currentView` from the `childViews` array - this
      eems odd???

A ContainerView is an Ember.View subclass that implements Ember.MutableArray
allowing programmatic management of its child views.

* `Ember.ContainerView` is a subclass of `Ember.View` (just like `Ember.Component` is)
* It implementes `Ember.MutableArray` ???
    * `pushObject()`
    * `removeObject()`
    * `toArray()`
* It allows you to manage child views in JS rather than implicitly in the templates

The following properties exist in `Ember.View` but do not make sense in an
`Ember.ContainerView`:

* template
* templateName, 
* defaultTemplate, 
* layout, 
* layoutName 
* defaultLayout

These will not result in the template or layout being rendered. The HTML
contents of a `Ember.ContainerView` DOM representation will **only be the rendered
HTML of its child views**.

### Example code for `Ember.ContainerView`

```
// MyApp namespace
window.MyApp = Ember.Application.create();

// Create the container
MyApp.container = Ember.ContainerView.create();

// Append the container to the document body 
MyApp.container.append();
MyApp.container.appendTo('#foo'); // where '#foo' is a string|DOM element|jQuery selector
// You can also plug a ContainerView into your app using the {{view}} handlebars
// helper in a template:
//      {{view App.container}}

// Grab child views array
var childViews = MyApp.container.get('childViews');

// Add text field
childViews.pushObject(Ember.TextField.create({
      value: 'Test'
}));

// Add checkbox
childViews.pushObject(Ember.Checkbox.create({
      value: true
}));

// Add custom view
childViews.pushObject(Ember.View.create({
      template: Handlebars.compile('<label>Awesome-O</label>')
}));
```

## View properties

```
attributeBindings: [] // a list of view properties to apply as attributes of the containing element
element: // returns the current DOM element for the view
isVisible: // is this view currently visible in the DOM
nearestOfType: // return the view object that is an instance of the provided class/mixin
                // this.nearestOfType(App.SomeKindOfView)
                
views: // a reference to the global views hash ???
classNames: []
classNameBindings: [] // a list of view properties to apply as class names to the containing element
tagName: 'div' // a string representing the HTML tag that will enclose the view
template: // function that gets a context and returns a HTML string
templateName: // the name of a template in Ember[TEMPLATES]
defaultTemplate: // function takes a context and returns HTML string, 
templateVariables:  // an object containing the variables that were in scope when
                    // the view was rendered

controller: // reference to an object that will be used as a context
            // if a view does not have an explicity controller property it will inherit the propertiy from it's parent
context: // reference to an object from which the template should access properties
parentView: a reference to the "parent" view //if neither controller nor context are set, then the parentView's context will be used

layout: // a function that takes a context and returns HTML string.
// the template you use for layout must have exactly one {{yield}} in it 
        // it will wrap the output of 'template' (or 'templateName')
layoutName: // string representing the name of a layout template

// * NB events in eventManager take precedence over events in child views that
//   are defined directly in that view
eventManager {
    // event handlers
    // * handlers in here swallow events so that child views will not see them.
    //   How does this work?
    click: function(jQueryEvent, view) {
        // stop propagation with 
        jQueryEvent.stopPropagation()
        // or
        return false; // same as jquery
    }
    mouseEnter: function(jQueryEvent, view) { }
}

// event handlers
// **************

// * any handlers defined in eventManager will override these
// * these handlers get different params than the handlers in eventManager

click: function(jQueryEvent) { }
mouseEnter: function(jQueryEvent) { }
// ...

```

If your template contains `{{view App.SomeView}}` then that view will be
rendered as a child view into the place where it appears in the template

### Disadvantages of using `eventManager`

* you cannot call the handler methods from other parts of your view as easily - really???
* You can inherit event handlers individually (which you can't do if they are
  all in one object (`eventManager`)

## View Methods

render()
    createElement() // called recursively by render()
// lifecycle hooks
didInsertElement()
willClearRender()

rerender() // redo the rendering process

$ // jquery object for this view's element e.g. myView.$('li') // find all <li> tags in current view


Ember.CollectionView.extend() // ???

Within a view `this.get('content')` will get you the context object (the object
that has properties you need)

Make a view by 
```
Ember.View.extend({});
```


```
// A pattern for running code after your view has been rendered
// * Just before the view is about to be rendered, you add some code ot the 'afterRender' queue which will be run once just afterwards
App.SomeView = Em.View.extend({
  template: '{{template "lots_of_images"}}',
  didInsertElement: function(){
    // This callback runs before lots_of_images has rendered.
    this.scheduleMasonry();
  },
  scheduleMasonry: (function(){
    // scheduleOnce debounces applyMasonry to only run once per
    // runloop. scheduleMasonry is called on didInsertElement, and
    // whenever controller.images changes.
    Ember.run.scheduleOnce('afterRender', this, this.applyMasonry);
  }).observes('controller.images.@each'),
  applyMasonry: function(){
    // http://masonry.desandro.com/index.html
    this.$('.container').masonry({
      itemSelector: '.item',
      columnWidth: 150
    });
  }
});

## Getting access to parents and children

Within a view
```
this.get('parentView'); // our parent
this.get('childViews'); // array of child view objects
```

Views have lifecycle hooks that you can attach handlers to

* willInsertElement
* didInsertElement
* willDestroyElement
* willClearRender
* becomeVisible
* becameHidden

You can register listeners to these events from outside the view (if you have a
reference to it)
```
view.on('willClearRender', function () {
});
```
This works because views use Ember's evented stuff

Ember comes wiht a bunch of events already defined incl. the drag & drop ones


The only way to craete a view hierarchy using templates is with the {{view}} helper

* Handlebars templates have a notion of the 'current view' (the view that is
closest) 
* it is accessible through the `{{view}}` helper e.g.
    {{view.someProp}}
* even though the handlebars context is the controller, {{view}} still points at
  the view

* Handlebars contexts can inherit properties from their parent contexts !!!
* Helpers can also create variables e.g. `{{#each users as user` creates `user` in the enclosed context
