* Bash (or zsh, if you prefer):  I bet most of us have a passing familiarity with a shell, but can you really use one?  Can you loop over some files without looking things up?  Can you diff the output of processes without throwing it into files that you are just going to delete?  Do you really understand how programs like tmux spawn off a process detached from your terminal and process group so that it can stick around even after your session ends?  There's a lot of power in knowing these things.

* Regular expression:  Choose a flavor (I recommend Oniguruma) and go deep.  I mean really deep.  Get to where you can use a look-around assertion confidently.  Learn how to write a recursive expression.  Build a parser for something that's not a good idea to parse with regular expressions, like HTML.  I have learned so much from stupid tricks like that and I swear the knowledge comes in handy on an almost daily basis.

* SQL:  Again, choose some database and go deep with learning what it can do.  I think most of us have gotten the hint by now that PostgreSQL is amazing (and it is), but I did this once with SQLite and that was super awesome.  Did you know SQLite has in-memory databases, hot backups, and will allow you to query across databases (not just tables)?  If you go this way, look into Jeremy's Amagalite gem, because it rocks too.
  * http://www.amazon.de/Joe-Celkos-SQL-Smarties-Fourth/dp/0123820227

* Forth. Seriously, this is one of the best foundation languages you can learn. It doesn't take that long, and you'll know stack machines inside and out. Being able to model a stack machine in your brain is a surprisingly useful tool when programming in high-level languages. If you don't want to mess around with Forth per se, the PostScript printer language contains pretty much everything in Forth plus some graphics primitives, so you can write programs on your laser printer. In college I used to write PostScript code to print squirals and fractals on the lab LaserWriter and give them to my stoner friends to hang in their dorm rooms next to their Grateful Dead posters.

* Smalltalk. Yeah, like you didn't see that one coming. But if you're working in Ruby, you should spend some time learning OOP in the most mature and pure OOP language around. It's amazing how clear things get when you aren't distracted by all the cool features Ruby adds on top of basic OOP.

* Prolog. Because constraint-based programming will blow your mind.

* Clojure or some other functional language
* clojure seems to have a bigger foothold on the web?
* Resources
  * https://leanpub.com/fp-oo
  * http://joyofclojure.com/the-book/

* Postscript