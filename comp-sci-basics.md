# Computer science basics

Sources

* http://steve-yegge.blogspot.co.nz/2008/03/get-that-job-at-google.html

## Math

Yegge reckons basic discrete math is important

* Applied Combinatorics
    * https://people.math.gatech.edu/~trotter/book.pdf
* Concrete Mathematics
    * https://notendur.hi.is/pgg/(ebook-pdf)%20-%20Mathematics%20-%20Concrete%20Mathematics.pdf

## Algorithms

* Introduction to Algorithms (MIT Course
    * MIT OCW: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/
    * Book: https://mitpress.mit.edu/books/introduction-algorithms
    * is available free with video lectures erc.
    * longer than the Algorithm design manual
    * Cormen, Leiserson, Rivest, and Stein, otherwise known as CLRS
* The Algorithm Design Manual
    * http://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202
    * shorter, concise, covers some data structures

Yegge really rates graphs as a tool

> Whenever someone gives you a problem, think graphs. They are the most
fundamental and flexible way of representing any kind of a relationship, so
it's about a 50-50 shot that any interesting design problem has a graph
involved in it. Make absolutely sure you can't think of a way to solve it using
graphs before moving on to other solution types.

* Algorithm complexity
* Sorting
* Graphs
* Hash tables
* Trees


Be able to recognise NP-complete problems such as

* Travelling salesman
* Knapsack

even when asked about them in the guise of a different problem


From <http://www.forbes.com/sites/quora/2013/07/03/how-do-i-strengthen-my-knowledge-of-data-structures-and-algorithms/#1e37aaf050c5>
which also recommends the MIT algorithms book:

> So stop trying to memorize everything. Instead, start with the basics and
> learn to do two things:
>
> Visualize the data structure. Intuitively understand what the data structure
> looks like, what it feels like to use it, and how it is structured both in the
> abstract and physically in your computer’s memory. This is the single most
> important thing you can do, and it is useful from the simplest queues and
> stacks up through the most complicated self-balancing tree. Draw it, visualize
> it in your head, whatever you need to do: Understand the structure intuitively.
>
> Learn when and how to use different data structures and their algorithms in
> your own code. This is harder as a student, as the problem assignments you’ll
> work through just won’t impart this knowledge. That’s fine. Realize you won’t
> master data structures until you are working on a real-world problem and
> discover that a hash is the solution to your performance woes. But even as a
> student you should focus on learning not the minutia details but the
> practicalities: When do you want a hash? When do you want a tree? When is a
> min-heap the right solution?

## Concurrency

Know about concurrency (mutexes, deadlocks, livelocks, threads, semaphores etc.)

* Book: Concurrency programming in Java
